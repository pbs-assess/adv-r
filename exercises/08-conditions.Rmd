---
title: "Foundations: Conditions"
output: rmarkdown::github_document
---

## 8.2 Signalling conditions

1. Write a wrapper around `file.remove()` that throws an error if the file to be deleted does not exist.

```{r}
library(rlang)
file.delete <- function(...){
  j <- as.vector(list(...))
  exists <- file.exists(...)
  j <- j[!exists]
  if(length(j)){
    stop("The following files could not be found:\n", paste(j, collapse = "\n"))
  }
  file.remove(...)
  invisible()
}
```

2. What does the `appendLF` argument to `message()` do? How is it related to `cat()`?

> It appends a linefeed to the message. It is passed to the hidden function `.makeMessage()` which in turn appends a linefeed (`\n`) to the output. If you use `cat()` you need to do this manually.

## 8.4 Handling conditions

1. What extra information does the condition generated by `abort()` contain compared to the condition generated by `stop()` i.e. whatâ€™s the difference between these two objects? Read the help for ?abort to learn more.

```{r}
catch_cnd(stop("An error"))
catch_cnd(abort("An error"))
```

> `stop()` includes the outer calling function unless `call. = FALSE` is set. `abort()` does this by default. `abort()` includes a backtrace in its output so you can see where the `abort` originated.

2. Predict the results of evaluating the following code

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

3. Explain the results of running this code:

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

> `message("c")` is caught by the outer `withCallingHandlers` block first, which issues `message("b")`. This is then caught by the inner `withCallingHandlers` block, which issues `message("a")`. This is caught by the outer `withCallingHandlers` block, which issues `message("b")`. If you print these out in the catching order you will get b, a, b, c as produced.

4. Read the source code for `catch_cnd()` and explain how it works.

> It just tries to execute the expression and catches an error with `tryCatch()`

5. How could you rewrite `show_condition()` to use a single handler?

```{r}
show_condition <- function(code){
  class(catch_cnd(code))[2]
}
```

